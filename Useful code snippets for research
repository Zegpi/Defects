Useful code snippets for research (start by doing edit-> code folding -> fold all)



//L2 projection of Al(0)+S:X
	#undef  __FUNCT__
	#define __FUNCT__ "L2ProjectionAlS"
	PetscErrorCode L2ProjectionAlS(IGAPoint p,IGAPoint pS,PetscReal *K,PetscReal *F,PetscReal *U,void *ctx)
	{
		if (p->atboundary)
		{
			return 0.0;																		//Pure Neumann condition 
		}

		//Modified to add S:X to alpha
		//Definition of alternating tensor
		const PetscReal e[3][3][3]=
		{
			{{0.0,0.0,0.0},{0.0,0.0,1.0},{0.0,-1.0,0.0}},
			{{0.0,0.0,-1.0},{0.0,0.0,0.0},{1.0,0.0,0.0}},
			{{0.0,1.0,0.0},{-1.0,0.0,0.0},{0.0,0.0,0.0}}
		};

		PetscReal S[8];
		IGAPointFormValue(pS,U,&S[0]);														//This fills the values of S
		PetscReal fullS[3][3][3]={0};

		fullS[0][0][0]=S[0]; fullS[0][0][1]=S[1]; fullS[0][1][0]=S[2]; fullS[0][1][1]=S[3];		//Expand S to full 3rd order form, only non-zero elements
		fullS[1][0][0]=S[4]; fullS[1][0][1]=S[5]; fullS[1][1][0]=S[6]; fullS[1][1][1]=S[7];

		AppCtxL2    *user  = (AppCtxL2 *)ctx;
		PetscReal Lx     = user->Lx;
		PetscReal Ly     = user->Ly;
		PetscReal nx     = user->nx;
		PetscReal ny     = user->ny;

		PetscInt a,b,i,j,k,l;
		PetscInt nen = p->nen;																//Number of shape functions, 9 in this case.
		PetscInt dim = p->dim;																//Number of spatial dimensions
		PetscInt dof = p->dof;

		PetscReal SX[3][3]={0};																//Stores S:X

		for(i=0; i<3;i++)
		{
			for (j=0; j<3; j++)
			{
				for (k=0; k<3; k++)
				{
					for (l=0; l<3; l++)
					{
						SX[i][j]=SX[i][j]+fullS[i][k][l]*e[j][k][l];
					}
				}
			}
		}

		PetscReal s[2]={0.0};
		s[0]=SX[0][2]; s[1]=SX[1][2];

		PetscReal x[dim];																	//Vector of reals, size equal to problem's dimension
		IGAPointFormGeomMap(p,x);															//Fills x with the coordinates of p, Gauss's point

		//g is the function to L2 project
		PetscReal dx=Lx/nx;
		PetscReal dy=Ly/ny;
		PetscReal eps=0.01;
		PetscReal g[dof];
		for (i=0; i<dof; i++)
		{
			if (i==0)
			{
				//g[i]=0*1.917545*(0.5*(tanh((x[0]+dx)/eps)+1.0)-0.5*(tanh((x[0]-dx)/eps)+1.0))*(0.5*(tanh((x[1]+dy)/eps)+1.0)-0.5*(tanh((x[1]-dy)/eps)+1.0));
				g[i]=0.0*0.9585551*0.5*(tanh((x[0]+dx)/eps)-tanh((x[0]-dx)/eps))*(tanh((x[1]+dy)/eps)-tanh((x[1]-dy)/eps));
			}
			else if (i==1)
			{
				//g[i]=1.917545*(0.5*(tanh((x[0]+dx)/eps)+1.0)-0.5*(tanh((x[0]-dx)/eps)+1.0))*(0.5*(tanh((x[1]+dy)/eps)+1.0)-0.5*(tanh((x[1]-dy)/eps)+1.0));
				g[i]=0.0*0.9585551*0.5*(tanh((x[0]+dx)/eps)-tanh((x[0]-dx)/eps))*(tanh((x[1]+dy)/eps)-tanh((x[1]-dy)/eps));
			}
		}

		const PetscReal (*N) = (typeof(N)) p->shape[0];
		PetscReal (*FF)[dof] = (PetscReal (*)[dof])F;
		PetscReal (*KK)[dof][nen][dof] = (PetscReal (*)[dof][nen][dof])K;
		for(a=0; a<nen; a++)
		{
			for(i=0; i<dof; i++) 
			{
				for(b=0; b<nen; b++)
				{
		  			KK[a][i][b][i] = N[a]*N[b];
		  		}
				FF[a][i] = N[a]*(g[i]+s[i]);
			}
		}
		return 0;
	}
//

//Creation of types and systems for the L2 projection of Alfa0+S:X
	//System for Alfa
	printf("System for L2 projection for Alfa+S:X starting \n");
	IGA igaAl;
	ierr = IGACreate(PETSC_COMM_WORLD,&igaAl);CHKERRQ(ierr);
	ierr = IGASetDim(igaAl,2);CHKERRQ(ierr);														//Spatial dimension of the problem
	ierr = IGASetDof(igaAl,2);CHKERRQ(ierr);														//Number of degrees of freedom, per node
	ierr = IGASetOrder(igaAl,1);CHKERRQ(ierr);													//Number of spatial derivatives to calculate
	ierr = IGASetFromOptions(igaAl);CHKERRQ(ierr);												//Note: The order (or degree) of the shape functions is given by the mesh!
	ierr = IGARead(igaAl,"./geometry.dat");CHKERRQ(ierr);
	ierr = IGASetUp(igaAl);CHKERRQ(ierr);
	//PetscInt dir,side;
	for (dir=0; dir<2; dir++) 
	{
		for (side=0; side<2; side++) 
		{
			//ierr = IGASetBoundaryValue(iga,dir,side,dof,0.0);CHKERRQ(ierr);    				// Dirichlet boundary conditions
			ierr = IGASetBoundaryForm(igaAl,dir,side,PETSC_TRUE);CHKERRQ(ierr);  				// Neumann boundary conditions
		}
	}
	
	Mat KAl;
	Vec al0,FAl;
	ierr = IGACreateMat(igaAl,&KAl);CHKERRQ(ierr);
	ierr = IGACreateVec(igaAl,&al0);CHKERRQ(ierr);
	ierr = IGACreateVec(igaAl,&FAl);CHKERRQ(ierr);

	IGAPoint        pointAl;
	IGAElement      elemAl;					//element
	PetscReal       *KlocAl,*FlocAl;			//AA y BB
	PetscReal       *KpointAl,*FpointAl;	//KKK y FFF
	const PetscReal *arrayS0Al;				//arrayU
	Vec  			localS0Al;				//localU
	PetscReal       *S0Al;					//U

  	IGAFormSystem  wtfAl;
 	void           *wtf2Al;

 	KSP kspAl;
	ierr = IGACreateKSP(igaAl,&kspAl);CHKERRQ(ierr);

	//Get local vectors s0 and arrays
	ierr = IGAGetLocalVecArray(igaS,s0,&localS0Al,&arrayS0Al);CHKERRQ(ierr);

	//Element loop
	ierr = IGABeginElement(igaAl,&elemAl);CHKERRQ(ierr);
	ierr = IGABeginElement(igaS,&elemS);CHKERRQ(ierr);

	while (IGANextElement(igaAl,elemAl))
	{
		IGANextElement(igaS,elemS);
		ierr = IGAElementGetWorkMat(elemAl,&KlocAl);CHKERRQ(ierr);
		ierr = IGAElementGetWorkVec(elemAl,&FlocAl);CHKERRQ(ierr);
		ierr = IGAElementGetValues(elemS,arrayS0Al,&S0Al);CHKERRQ(ierr);

		//FormSystem loop
		while (IGAElementNextFormSystem(elemAl,&wtfAl,&wtf2Al)) 
		{
			//Quadrature loop
			ierr = IGAElementBeginPoint(elemAl,&pointAl);CHKERRQ(ierr);
			ierr = IGAElementBeginPoint(elemS,&pointS);CHKERRQ(ierr);
			if(pointAl->atboundary==0 && pointS->atboundary==0)
			{
				while (IGAElementNextPoint(elemAl,pointAl)) 
				{
					IGAElementNextPoint(elemS,pointS);
					ierr = IGAPointGetWorkMat(pointAl,&KpointAl);CHKERRQ(ierr);
					ierr = IGAPointGetWorkVec(pointAl,&FpointAl);CHKERRQ(ierr);
					ierr = L2ProjectionAlS(pointAl,pointS,KpointAl,FpointAl,S0Al,&userL2);CHKERRQ(ierr);
					ierr = IGAPointAddMat(pointAl,KpointAl,KlocAl);CHKERRQ(ierr);
					ierr = IGAPointAddVec(pointAl,FpointAl,FlocAl);CHKERRQ(ierr);
				}
				IGAElementNextPoint(elemS,pointS);
				ierr = IGAElementEndPoint(elemAl,&pointAl);CHKERRQ(ierr);
				ierr = IGAElementEndPoint(elemS,&pointS);CHKERRQ(ierr);
			}
		}
		ierr = IGAElementFixSystem(elemAl,KlocAl,FlocAl);CHKERRQ(ierr);					//This sets Dirichlet condition ¿?
		ierr = IGAElementAssembleMat(elemAl,KlocAl,KAl);CHKERRQ(ierr);
		ierr = IGAElementAssembleVec(elemAl,FlocAl,FAl);CHKERRQ(ierr);

	}
	IGANextElement(igaS,elemS);
	ierr = IGAEndElement(igaAl,&elemAl);CHKERRQ(ierr);
	ierr = IGAEndElement(igaS,&elemS);CHKERRQ(ierr);

	// Restore local vectors s0 and arrays
	ierr = IGARestoreLocalVecArray(igaS,s0,&localS0Al,&arrayS0Al);CHKERRQ(ierr);

	//Form system matrix and vector
	ierr = MatAssemblyBegin(KAl,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
	ierr = MatAssemblyEnd  (KAl,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
	
	ierr = VecAssemblyBegin(FAl);CHKERRQ(ierr);
	ierr = VecAssemblyEnd  (FAl);CHKERRQ(ierr);

	ierr = KSPSetOperators(kspAl,KAl,KAl);CHKERRQ(ierr);
	ierr = KSPSetFromOptions(kspAl);CHKERRQ(ierr);
	ierr = KSPSolve(kspAl,FAl,al0);CHKERRQ(ierr);

	ierr = KSPDestroy(&kspAl);CHKERRQ(ierr);
	ierr = MatDestroy(&KAl);CHKERRQ(ierr);
	ierr = VecDestroy(&FAl);CHKERRQ(ierr);
	
	char nameAl[]="/Al-2d-0.dat";
	char pathAl[512];
	sprintf(pathAl,"%s%s",direct,nameAl);
	ierr = IGAWriteVec(igaAl,al0,pathAl);CHKERRQ(ierr);
//

//System for z(0)
	#undef  __FUNCT__
	#define __FUNCT__ "Z0sys"
	PetscErrorCode Z0sys(IGAPoint p,IGAPoint pChi,IGAPoint pHs,PetscReal *K,PetscReal *F, PetscReal *UChi,PetscReal *UHs,void *ctx)
	{
		PetscReal C[3][3][3][3]={0};														//Initialization of elastic tensor
		const PetscReal *N0,(*N1)[2],(*N2)[2][2];
		IGAPointGetShapeFuns(p,0,(const PetscReal**)&N0);									//Value of the shape functions
		IGAPointGetShapeFuns(p,1,(const PetscReal**)&N1);									//Derivatives of the shape functions
		IGAPointGetShapeFuns(p,2,(const PetscReal**)&N2);									//Second derivatives of the shape funcions
		//After this command Na_xx=N2[a][0][0], Na_yy=N2[a][1][1], Na_xy=N2[a][0][1], Na_yx[a][1][0] (these last two are equal) (remember a is the index of the shape function)
		PetscInt a,b,i,j,k,l,u,w,r,s,m,nen=p->nen, dof=p->dof;

		PetscReal Chi0[4];																//Assign Al(t) to a vector
		PetscReal dChi0[4][2];															//Same for partial derivatives
		IGAPointFormValue(pChi,UChi,&Chi0[0]);
		IGAPointFormGrad (pChi,UChi,&dChi0[0][0]);

		PetscReal fullChi[3][3];
		fullChi[0][0]=Chi0[0]; 	fullChi[0][1]=Chi0[1]; 	fullChi[0][2]=0;
		fullChi[1][0]=Chi0[2]; 	fullChi[1][1]=Chi0[3]; 	fullChi[1][2]=0;
		fullChi[2][0]=0; 		fullChi[2][1]=0; 		fullChi[2][2]=0;

		PetscReal full_dChi[3][3][3]={0};
		full_dChi[0][0][0]=dChi0[0][0]; full_dChi[0][0][1]=dChi0[0][1];
		full_dChi[0][1][0]=dChi0[1][0]; full_dChi[0][1][1]=dChi0[1][1];
		full_dChi[1][0][0]=dChi0[2][0]; full_dChi[1][0][1]=dChi0[2][1];
		full_dChi[1][1][0]=dChi0[3][0]; full_dChi[1][1][1]=dChi0[3][1];

		PetscReal Hs0[4];
		PetscReal dHs0[4][2];
		IGAPointFormValue(pHs,UHs,&Hs0[0]);
		IGAPointFormGrad (pHs,UHs,&dHs0[0][0]);

		PetscReal fullHs[3][3];
		fullHs[0][0]=Hs0[0]; 	fullHs[0][1]=Hs0[1]; 	fullHs[0][2]=0;
		fullHs[1][0]=Hs0[2]; 	fullHs[1][1]=Hs0[3]; 	fullHs[1][2]=0;
		fullHs[2][0]=0; 		fullHs[2][1]=0; 		fullHs[2][2]=0;

		//PetscReal x[2], xh[2];
		//IGAPointFormGeomMap(p,x);
		//IGAPointFormGeomMap(pHs,xh);

		//PetscPrintf(PETSC_COMM_WORLD,"p is at (%f , %f) and pH is at (%f , %f) \n",x[0],x[1],xh[0],xh[1]);
		//PetscPrintf(PETSC_COMM_WORLD,"Hs[0]= %f, Hs[1]= %f, Hs[2]= %f, Hs[3]= %f \n",Hs0[0],Hs0[1],Hs0[2],Hs0[3]);

		PetscReal full_dHs[3][3][3]={0};
		full_dHs[0][0][0]=dHs0[0][0]; full_dHs[0][0][1]=dHs0[0][1];
		full_dHs[0][1][0]=dHs0[1][0]; full_dHs[0][1][1]=dHs0[1][1];
		full_dHs[1][0][0]=dHs0[2][0]; full_dHs[1][0][1]=dHs0[2][1];
		full_dHs[1][1][0]=dHs0[3][0]; full_dHs[1][1][1]=dHs0[3][1];


		PetscReal (*Keq)[dof][nen][dof] = (typeof(Keq)) K;
		PetscReal (*Feq)[dof] = (PetscReal (*)[dof])F;

		//E and nu should come from AppCtx in the future
		const PetscReal E=2100000.0*9.81*10000.0;
		const PetscReal nu=0.33;
		const PetscReal lambda=(E*nu)/((1.0+nu)*(1.0-2.0*nu));
		const PetscReal mu=E/(2.0*(1.0+nu));
		const PetscReal eps=E/1000.0;							//Choose later based on whatever Amit says :)

		//////////////Delete this parte later, loads should come from appCtx or be 0
		//PetscReal f[2]={0.0, 0.0};			//Distributed load in body
		//PetscReal g[2]={0.0, 0.0};			//Boundary load (applied wherever is defined in the p->atboundary block)
		//PetscReal M[3]={0.0, 0.0, 0.0};		//Distributed load in body
		//PetscReal h[3]={0.0, 0.0, E};		//Boundary moment (applied wherever is defined in the p->atboundary block)
		/////////////////////////////////////
		/*
		const PetscReal e[3][3][3]=
		{
			{{0.0,0.0,0.0},{0.0,0.0,1.0},{0.0,-1.0,0.0}},
			{{0.0,0.0,-1.0},{0.0,0.0,0.0},{1.0,0.0,0.0}},
			{{0.0,1.0,0.0},{-1.0,0.0,0.0},{0.0,0.0,0.0}}
		};
		*/

		//Creation of elasticity tensor
		for (i=0; i<3; i++)
		{
			for (j=0; j<3; j++)
			{
				for (k=0; k<3; k++)
				{
					for (l=0; l<3; l++)
					{
						C[i][j][k][l]=lambda*delta(i,j)*delta(k,l)+mu*(delta(i,k)*delta(j,l)+delta(i,l)*delta(j,k));
					}
				}
			}
		}

		PetscReal gz[3][3]={0};
		PetscReal ez[3][3]={0};
		PetscReal ev[3][3]={0};
		PetscReal dev[3][3][3]={0};
		PetscReal dz[3][3][3]={0};
		PetscReal dv[3][3][3]={0};

		//Consider deleting the "atboundary" block for speed, no boundary loads on this problem
		if (p->atboundary)
		{
			return 0;
		}
		else
		{
			for (a=0; a<nen; a++) 
			{
				PetscReal Na_x = N1[a][0];
				PetscReal Na_y = N1[a][1];
				PetscReal Na_xx =N2[a][0][0];
				PetscReal Na_yy =N2[a][1][1];
				PetscReal Na_xy =N2[a][0][1];
				PetscReal Na_yx =N2[a][1][0];

				for (b=0; b<nen; b++) 
				{
					PetscReal Nb_x = N1[b][0];
					PetscReal Nb_y = N1[b][1];
					PetscReal Nb_xx =N2[b][0][0];
					PetscReal Nb_yy =N2[b][1][1];
					PetscReal Nb_xy =N2[b][0][1];
					PetscReal Nb_yx =N2[b][1][0];

					for (i=0; i<dof; i++)
					{
						if (i==0)
						{
							ev[0][0]=Na_x; 	ev[0][1]=0.5*Na_y; ev[1][0]=0.5*Na_y; ev[1][1]=0.0; ev[2][0]=0.0; ev[2][1]=0.0; ev[2][2]=0.0; ev[0][2]=0.0; ev[1][2]=0.0;
							
							dev[0][0][0]=Na_xx; dev[0][1][0]=0.5*Na_yx; dev[1][0][0]=0.5*Na_yx; dev[1][1][0]=0; dev[2][0][0]=0; dev[2][1][0]=0; dev[2][2][0]=0; dev[0][2][0]=0; dev[1][2][0]=0;
							dev[0][0][1]=Na_xy; dev[0][1][1]=0.5*Na_yy; dev[1][0][1]=0.5*Na_yy; dev[1][1][1]=0; dev[2][0][1]=0; dev[2][1][1]=0; dev[2][2][1]=0; dev[0][2][1]=0; dev[1][2][1]=0;
							dev[0][0][2]=0; 	dev[0][1][2]=0; 		dev[1][0][2]=0; 		dev[1][1][2]=0; dev[2][0][2]=0; dev[2][1][2]=0; dev[2][2][2]=0; dev[0][2][2]=0; dev[1][2][2]=0;
							dv[0][0][0]=Na_xx; dv[0][0][1]=Na_xy; dv[0][0][2]=0.0; dv[0][1][0]=Na_yx; dv[0][1][1]=Na_yy; dv[0][1][2]=0.0; dv[0][2][0]=0.0; dv[0][2][1]=0.0; dv[0][2][2]=0.0;
							dv[1][0][0]=0.00;  dv[1][0][1]=0.00;  dv[1][0][2]=0.0; dv[1][1][0]=0.0;   dv[1][1][1]=0.0;   dv[1][1][2]=0.0; dv[1][2][0]=0.0; dv[1][2][1]=0.0; dv[1][2][2]=0.0;
							dv[2][0][0]=0.00;  dv[2][0][1]=0.00;  dv[2][0][2]=0.0; dv[2][1][0]=0.0;   dv[2][1][1]=0.0;   dv[2][1][2]=0.0; dv[2][2][0]=0.0; dv[2][2][1]=0.0; dv[2][2][2]=0.0;
							
						}
						else if(i==1)
						{
							ev[0][0]=0.0; ev[0][1]=0.5*Na_x; ev[1][0]=0.5*Na_x; ev[1][1]=Na_y; ev[2][0]=0.0; ev[2][1]=0.0; ev[2][2]=0.0; ev[0][2]=0.0; ev[1][2]=0.0;
							dev[0][0][0]=0; dev[0][1][0]=0.5*Na_xx; dev[1][0][0]=0.5*Na_xx; dev[1][1][0]=Na_yx; dev[2][0][0]=0; dev[2][1][0]=0; dev[2][2][0]=0; dev[0][2][0]=0; dev[1][2][0]=0;
							dev[0][0][1]=0; dev[0][1][1]=0.5*Na_xy; dev[1][0][1]=0.5*Na_xy; dev[1][1][1]=Na_yy; dev[2][0][1]=0; dev[2][1][1]=0; dev[2][2][1]=0; dev[0][2][1]=0; dev[1][2][1]=0;
							dev[0][0][2]=0; dev[0][1][2]=0; 		dev[1][0][2]=0; 		dev[1][1][2]=0; 	dev[2][0][2]=0; dev[2][1][2]=0; dev[2][2][2]=0; dev[0][2][2]=0; dev[1][2][2]=0;
							dv[0][0][0]=0.00;  dv[0][0][1]=0.00;  dv[0][0][2]=0.0; dv[0][1][0]=0.0;   dv[0][1][1]=0.0;   dv[0][1][2]=0.0; dv[0][2][0]=0.0; dv[0][2][1]=0.0; dv[0][2][2]=0.0;
							dv[1][0][0]=Na_xx; dv[1][0][1]=Na_xy; dv[1][0][2]=0.0; dv[1][1][0]=Na_yx; dv[1][1][1]=Na_yy; dv[1][1][2]=0.0; dv[1][2][0]=0.0; dv[1][2][1]=0.0; dv[1][2][2]=0.0;
							dv[2][0][0]=0.00;  dv[2][0][1]=0.00;  dv[2][0][2]=0.0; dv[2][1][0]=0.0;   dv[2][1][1]=0.0;   dv[2][1][2]=0.0; dv[2][2][0]=0.0; dv[2][2][1]=0.0; dv[2][2][2]=0.0;
							
						}

						for (j=0; j<dof; j++)
						{
							if (j==0)
							{
								gz[0][0]=Nb_x; gz[0][1]=Nb_y; gz[1][0]=0; gz[1][1]=0;
								ez[0][0]=Nb_x; ez[0][1]=0.5*Nb_y; ez[1][0]=0.5*Nb_y; ez[1][1]=0.0; ez[2][0]=0.0; ez[2][1]=0.0; ez[2][2]=0.0; ez[0][2]=0.0; ez[1][2]=0.0;

								dz[0][0][0]=Nb_xx; dz[0][0][1]=Nb_xy; dz[0][0][2]=0.0; dz[0][1][0]=Nb_yx; dz[0][1][1]=Nb_yy; dz[0][1][2]=0.0; dz[0][2][0]=0.0; dz[0][2][1]=0.0; dz[0][2][2]=0.0;
								dz[1][0][0]=0.00;  dz[1][0][1]=0.00;  dz[1][0][2]=0.0; dz[1][1][0]=0.0;   dz[1][1][1]=0.0;   dz[1][1][2]=0.0; dz[1][2][0]=0.0; dz[1][2][1]=0.0; dz[1][2][2]=0.0;
								dz[2][0][0]=0.00;  dz[2][0][1]=0.00;  dz[2][0][2]=0.0; dz[2][1][0]=0.0;   dz[2][1][1]=0.0;   dz[2][1][2]=0.0; dz[2][2][0]=0.0; dz[2][2][1]=0.0; dz[2][2][2]=0.0;
							}
							else if(j==1)
							{
								gz[0][0]=0.0; gz[0][1]=0.0; gz[1][0]=Nb_x; gz[1][1]=Nb_y;
								ez[0][0]=0.0; ez[0][1]=0.5*Nb_x; ez[1][0]=0.5*Nb_x; ez[1][1]=Nb_y; ez[2][0]=0.0; ez[2][1]=0.0; ez[2][2]=0.0; ez[0][2]=0.0; ez[1][2]=0.0;

								dz[0][0][0]=0.00;  dz[0][0][1]=0.00;  dz[0][0][2]=0.0; dz[0][1][0]=0.0;   dz[0][1][1]=0.0;   dz[0][1][2]=0.0; dz[0][2][0]=0.0; dz[0][2][1]=0.0; dz[0][2][2]=0.0;
								dz[1][0][0]=Nb_xx; dz[1][0][1]=Nb_xy; dz[1][0][2]=0.0; dz[1][1][0]=Nb_yx; dz[1][1][1]=Nb_yy; dz[1][1][2]=0.0; dz[1][2][0]=0.0; dz[1][2][1]=0.0; dz[1][2][2]=0.0;
								dz[2][0][0]=0.00;  dz[2][0][1]=0.00;  dz[2][0][2]=0.0; dz[2][1][0]=0.0;   dz[2][1][1]=0.0;   dz[2][1][2]=0.0; dz[2][2][0]=0.0; dz[2][2][1]=0.0; dz[2][2][2]=0.0;
							}

							Keq[a][i][b][j]=0.0;
							for (k=0; k<3; k++)
							{
								for (l=0; l<3; l++)
								{
									for (u=0; u<3; u++)
									{
										for (w=0; w<3; w++)
										{
											Keq[a][i][b][j]+=-C[k][l][u][w]*gz[u][w]*ev[k][l];			//Why ez is symmetrized? does it matter or does C take care of
										}
									}
								}
							}

							for (r=0; r<3; r++)
							{
								for (s=0; s<3; s++)
								{
									for (m=0; m<3; m++)
									{
										Keq[a][i][b][j]+=-0.25*eps*(dz[r][s][m]+dz[r][m][s]+dz[s][r][m]+dz[s][m][r])*dev[r][s][m]-0.25*eps*(dz[r][s][m]+dz[r][m][s])*dv[r][s][m]
														 +0.25*eps*(dz[s][r][m]+dz[s][m][r])*dv[r][s][m];
									}
								}
							}
						}
					}
				}
			}

			for(a=0 ;a<nen; a++)
			{
				for (i=0; i<dof; i++)
				{
					PetscReal Na_x=N1[a][0];
					PetscReal Na_y=N1[a][1];
					PetscReal Na_xx =N2[a][0][0];
					PetscReal Na_yy =N2[a][1][1];
					PetscReal Na_xy =N2[a][0][1];
					PetscReal Na_yx =N2[a][1][0];

					if (i==0)
					{
						ev[0][0]=Na_x; ev[0][1]=0.5*Na_y; ev[1][0]=0.5*Na_y; ev[1][1]=0.0; ev[2][0]=0.0; ev[2][1]=0.0; ev[2][2]=0.0; ev[0][2]=0.0; ev[1][2]=0.0;

						dev[0][0][0]=Na_xx; dev[0][1][0]=0.5*Na_yx; dev[1][0][0]=0.5*Na_yx; dev[1][1][0]=0; dev[2][0][0]=0; dev[2][1][0]=0; dev[2][2][0]=0; dev[0][2][0]=0; dev[1][2][0]=0;
						dev[0][0][1]=Na_xy; dev[0][1][1]=0.5*Na_yy; dev[1][0][1]=0.5*Na_yy; dev[1][1][1]=0; dev[2][0][1]=0; dev[2][1][1]=0; dev[2][2][1]=0; dev[0][2][1]=0; dev[1][2][1]=0;
						dev[0][0][2]=0; 	dev[0][1][2]=0; 		dev[1][0][2]=0; 		dev[1][1][2]=0; dev[2][0][2]=0; dev[2][1][2]=0; dev[2][2][2]=0; dev[0][2][2]=0; dev[1][2][2]=0;

						dv[0][0][0]=Na_xx; dv[0][0][1]=Na_xy; dv[0][0][2]=0.0; dv[0][1][0]=Na_yx; dv[0][1][1]=Na_yy; dv[0][1][2]=0.0; dv[0][2][0]=0.0; dv[0][2][1]=0.0; dv[0][2][2]=0.0;
						dv[1][0][0]=0.00;  dv[1][0][1]=0.00;  dv[1][0][2]=0.0; dv[1][1][0]=0.0;   dv[1][1][1]=0.0;   dv[1][1][2]=0.0; dv[1][2][0]=0.0; dv[1][2][1]=0.0; dv[1][2][2]=0.0;
						dv[2][0][0]=0.00;  dv[2][0][1]=0.00;  dv[2][0][2]=0.0; dv[2][1][0]=0.0;   dv[2][1][1]=0.0;   dv[2][1][2]=0.0; dv[2][2][0]=0.0; dv[2][2][1]=0.0; dv[2][2][2]=0.0;
					}
					else if (i==1)
					{
						ev[0][0]=0.0; ev[0][1]=0.5*Na_x; ev[1][0]=0.5*Na_x; ev[1][1]=Na_y; ev[2][0]=0.0; ev[2][1]=0.0; ev[2][2]=0.0; ev[0][2]=0.0; ev[1][2]=0.0;

						dev[0][0][0]=0; dev[0][1][0]=0.5*Na_xx; dev[1][0][0]=0.5*Na_xx; dev[1][1][0]=Na_yx; dev[2][0][0]=0; dev[2][1][0]=0; dev[2][2][0]=0; dev[0][2][0]=0; dev[1][2][0]=0;
						dev[0][0][1]=0; dev[0][1][1]=0.5*Na_xy; dev[1][0][1]=0.5*Na_xy; dev[1][1][1]=Na_yy; dev[2][0][1]=0; dev[2][1][1]=0; dev[2][2][1]=0; dev[0][2][1]=0; dev[1][2][1]=0;
						dev[0][0][2]=0; dev[0][1][2]=0; 		dev[1][0][2]=0; 		dev[1][1][2]=0; 	dev[2][0][2]=0; dev[2][1][2]=0; dev[2][2][2]=0; dev[0][2][2]=0; dev[1][2][2]=0;

						dv[0][0][0]=0.00;  dv[0][0][1]=0.00;  dv[0][0][2]=0.0; dv[0][1][0]=0.0;   dv[0][1][1]=0.0;   dv[0][1][2]=0.0; dv[0][2][0]=0.0; dv[0][2][1]=0.0; dv[0][2][2]=0.0;
						dv[1][0][0]=Na_xx; dv[1][0][1]=Na_xy; dv[1][0][2]=0.0; dv[1][1][0]=Na_yx; dv[1][1][1]=Na_yy; dv[1][1][2]=0.0; dv[1][2][0]=0.0; dv[1][2][1]=0.0; dv[1][2][2]=0.0;
						dv[2][0][0]=0.00;  dv[2][0][1]=0.00;  dv[2][0][2]=0.0; dv[2][1][0]=0.0;   dv[2][1][1]=0.0;   dv[2][1][2]=0.0; dv[2][2][0]=0.0; dv[2][2][1]=0.0; dv[2][2][2]=0.0;
					}

					Feq[a][i] = 0.0;


					for (k=0; k<3; k++)
					{
						for (l=0; l<3; l++)
						{
							for (u=0; u<3; u++)
							{
								for (w=0; w<3; w++)
								{
									Feq[a][i]+=C[k][l][u][w]*(fullChi[u][w]-fullHs[u][w])*ev[k][l];
								}
							}
						}
					}

					for (r=0; r<3; r++)
					{
						for (s=0; s<3; s++)
						{
							for (m=0; m<3; m++)
							{
								Feq[a][i]+=0.25*eps*(full_dChi[r][s][m]-full_dHs[r][s][m]+full_dChi[r][m][s]-full_dHs[r][m][s])*dev[r][s][m]
										  +0.25*eps*(full_dChi[s][r][m]-full_dHs[s][r][m]+full_dChi[s][m][r]-full_dHs[s][m][r])*dev[r][s][m]
										  +0.25*eps*(full_dChi[r][s][m]-full_dHs[r][s][m]+full_dChi[r][m][s]-full_dHs[r][m][s])*dv[r][s][m]
										  -0.25*eps*(full_dChi[s][r][m]-full_dHs[s][r][m]+full_dChi[s][m][r]-full_dHs[s][m][r])*dv[r][s][m];
							}
						}
					}
				}
			}
		}
		
		return 0;
	}
//

//System for initial state of z (does not work correctly with the split Ûe=grad(u)-chi-z+Hs)
	PetscPrintf(PETSC_COMM_WORLD,"System for Z0 starting \n");
	IGA igaZ0;
	ierr = IGACreate(PETSC_COMM_WORLD,&igaZ0);CHKERRQ(ierr);
	ierr = IGASetDim(igaZ0,2);CHKERRQ(ierr);													//Spatial dimension of the problem
	ierr = IGASetDof(igaZ0,2);CHKERRQ(ierr);													//Number of degrees of freedom, per node
	ierr = IGASetOrder(igaZ0,2);CHKERRQ(ierr);													//Number of spatial derivatives to calculate
	ierr = IGASetFromOptions(igaZ0);CHKERRQ(ierr);												//Note: The order (or degree) of the shape functions is given by the mesh!
	ierr = IGARead(igaZ0,"./geometry2.dat");CHKERRQ(ierr);
	ierr = IGASetUp(igaZ0);CHKERRQ(ierr);

	Mat KZ0;
	Vec Z0,FZ0;

	ierr = IGACreateMat(igaZ0,&KZ0);CHKERRQ(ierr);
	ierr = IGACreateVec(igaZ0,&Z0);CHKERRQ(ierr);
	ierr = IGACreateVec(igaZ0,&FZ0);CHKERRQ(ierr);

	IGAPoint		pointZ0;						//point
	IGAElement		elemZ0;							//element
	PetscReal		*KlocZ0,*FlocZ0;				//AA y BB
	PetscReal		*KpointZ0,*FpointZ0;			//KKK y FFF
	const PetscReal	*arrayChi0Z0,*arrayHsZ0;		//arrayU
	Vec				localChi0Z0,localHsZ0;			//localU
	PetscReal		*Chi0Z0,*HsZ0;					//U

  	IGAFormSystem	wtfZ0;
 	void			*wtf2Z0;

 	KSP kspZ0;
	ierr = IGACreateKSP(igaZ0,&kspZ0);CHKERRQ(ierr);

	// Get local vectors Chi0 and arrays
	ierr = IGAGetLocalVecArray(igachiUp,chiUp0,&localChi0Z0,&arrayChi0Z0);CHKERRQ(ierr);
	ierr = IGAGetLocalVecArray(igaZS,ZS0,&localHsZ0,&arrayHsZ0);CHKERRQ(ierr);

	// Element loop
	ierr = IGABeginElement(igaZ0,&elemZ0);CHKERRQ(ierr);
	ierr = IGABeginElement(igachiUp,&elemchiUp);CHKERRQ(ierr);
	ierr = IGABeginElement(igaZS,&elemZS);CHKERRQ(ierr);

	while (IGANextElement(igaZ0,elemZ0)) 
	{
		IGANextElement(igachiUp,elemchiUp);
		IGANextElement(igaZS,elemZS);

		ierr = IGAElementGetWorkMat(elemZ0,&KlocZ0);CHKERRQ(ierr);
		ierr = IGAElementGetWorkVec(elemZ0,&FlocZ0);CHKERRQ(ierr);
		ierr = IGAElementGetValues(elemchiUp,arrayChi0Z0,&Chi0Z0);CHKERRQ(ierr);
		ierr = IGAElementGetValues(elemZS,arrayHsZ0,&HsZ0);CHKERRQ(ierr);

		// FormSystem loop
		while (IGAElementNextFormSystem(elemZ0,&wtfZ0,&wtf2Z0)) 
		{
		// Quadrature loop
			ierr = IGAElementBeginPoint(elemZ0,&pointZ0);CHKERRQ(ierr);
			ierr = IGAElementBeginPoint(elemchiUp,&pointchiUp);CHKERRQ(ierr);
			ierr = IGAElementBeginPoint(elemZS,&pointZS);CHKERRQ(ierr);

			while (IGAElementNextPoint(elemZ0,pointZ0))
			{
				/*
				if(pointZ0->atboundary==1)
				{
					ierr = IGAPointGetWorkMat(pointZ0,&KpointZ0);CHKERRQ(ierr);
					ierr = IGAPointGetWorkVec(pointZ0,&FpointZ0);CHKERRQ(ierr);
					ierr = Z0sys(pointZ0,pointChi,KpointZ0,FpointZ0,Chi0Z0,NULL);CHKERRQ(ierr);
					ierr = IGAPointAddMat(pointZ0,KpointZ0,KlocZ0);CHKERRQ(ierr);
					ierr = IGAPointAddVec(pointZ0,FpointZ0,FlocZ0);CHKERRQ(ierr);
				}
				*/

				if(pointZ0->atboundary==0 && pointchiUp->atboundary==0 && pointZS->atboundary==0)
				{
					IGAElementNextPoint(elemchiUp,pointchiUp);
					IGAElementNextPoint(elemZS,pointZS);

					ierr = IGAPointGetWorkMat(pointZ0,&KpointZ0);CHKERRQ(ierr);
					ierr = IGAPointGetWorkVec(pointZ0,&FpointZ0);CHKERRQ(ierr);
					ierr = Z0sys(pointZ0,pointchiUp,pointZS,KpointZ0,FpointZ0,Chi0Z0,HsZ0,NULL);CHKERRQ(ierr);
					ierr = IGAPointAddMat(pointZ0,KpointZ0,KlocZ0);CHKERRQ(ierr);
					ierr = IGAPointAddVec(pointZ0,FpointZ0,FlocZ0);CHKERRQ(ierr);
				}
			}
			if (pointchiUp->index != -1)
			{
				IGAElementNextPoint(elemchiUp,pointchiUp);
			}
			if (pointZS->index != -1)
			{
				IGAElementNextPoint(elemZS,pointZS);
			}
			ierr = IGAElementEndPoint(elemZ0,&pointZ0);CHKERRQ(ierr);
			ierr = IGAElementEndPoint(elemchiUp,&pointchiUp);CHKERRQ(ierr);
			ierr = IGAElementEndPoint(elemZS,&pointZS);CHKERRQ(ierr);
		}

		ierr = IGAElementFixSystem(elemZ0,KlocZ0,FlocZ0);CHKERRQ(ierr);					//This sets Dirichlet condition ¿? (Yes, this applies the conditions from IGASetBoundaryValue)
		ierr = IGAElementAssembleMat(elemZ0,KlocZ0,KZ0);CHKERRQ(ierr);
		ierr = IGAElementAssembleVec(elemZ0,FlocZ0,FZ0);CHKERRQ(ierr);

	}
	IGANextElement(igachiUp,elemchiUp);
	IGANextElement(igaZS,elemZS);

	ierr = IGAEndElement(igaZ0,&elemZ0);CHKERRQ(ierr);
	ierr = IGAEndElement(igachiUp,&elemchiUp);CHKERRQ(ierr);
	ierr = IGAEndElement(igaZS,&elemZS);CHKERRQ(ierr);

	// Restore local vectors Chi0 and arrays
	ierr = IGARestoreLocalVecArray(igachiUp,chiUp0,&localChi0Z0,&arrayChi0Z0);CHKERRQ(ierr);
	ierr = IGARestoreLocalVecArray(igaZS,ZS0,&localHsZ0,&arrayHsZ0);CHKERRQ(ierr);

	//Here we set values to the Matrix directly (to impose Dirichlet condition in a single point)
	ierr = MatAssemblyBegin(KZ0,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
	ierr = MatAssemblyEnd  (KZ0,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
	
	rows=0;
	ierr = MatZeroRows(KZ0,1,&rows,1.0e30,0,0);CHKERRQ(ierr);
	rows=1;
	ierr = MatZeroRows(KZ0,1,&rows,1.0e30,0,0);CHKERRQ(ierr);
	rows=2*(nx+2);
	ierr = MatZeroRows(KZ0,1,&rows,1.0e30,0,0);CHKERRQ(ierr);

	ierr = MatAssemblyBegin(KZ0,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
	ierr = MatAssemblyEnd  (KZ0,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);

	//Here we set values to the vector directly (to impose Dirichlet condition in a single point)
	ierr = VecAssemblyBegin(FZ0);CHKERRQ(ierr);
	ierr = VecAssemblyEnd  (FZ0);CHKERRQ(ierr);
	
	rows=0;
	vals=0.0;
	ierr = VecSetValue(FZ0,rows,vals,INSERT_VALUES);CHKERRQ(ierr);
	rows=1;
	vals=0.0;
	ierr = VecSetValue(FZ0,rows,vals,INSERT_VALUES);CHKERRQ(ierr);
	rows=2*(nx+2);
	vals=0.0;
	ierr = VecSetValue(FZ0,rows,vals,INSERT_VALUES);CHKERRQ(ierr);
	ierr = VecAssemblyBegin(FZ0);CHKERRQ(ierr);
	ierr = VecAssemblyEnd  (FZ0);CHKERRQ(ierr);

	//Hasta aqui

	ierr = KSPSetOperators(kspZ0,KZ0,KZ0);CHKERRQ(ierr);
	PC pcZ0;
	ierr = KSPGetPC(kspZ0,&pcZ0); CHKERRQ(ierr);
	ierr = PCSetType(pcZ0,PCLU); CHKERRQ(ierr);
	ierr = PCFactorSetMatSolverType(pcZ0,MATSOLVERMUMPS); CHKERRQ(ierr);
	ierr = KSPSetFromOptions(kspZ0);CHKERRQ(ierr);
	ierr = KSPSetFromOptions(kspZ0);CHKERRQ(ierr);
	ierr = KSPSetTolerances(kspZ0,1e-16,PETSC_DEFAULT,PETSC_DEFAULT,PETSC_DEFAULT);CHKERRQ(ierr);
	ierr = KSPSolve(kspZ0,FZ0,Z0);CHKERRQ(ierr);

	ierr = KSPDestroy(&kspZ0);CHKERRQ(ierr);
	ierr = MatDestroy(&KZ0);CHKERRQ(ierr);
	ierr = VecDestroy(&FZ0);CHKERRQ(ierr);
	//ierr = IGAWriteVec(igaZ0,z0,"./results/z0-2d-0.dat");CHKERRQ(ierr);
	char nameZ0[]="/Z0-2d-0.dat";
	char pathZ0[512];
	sprintf(pathZ0,"%s%s",direct,nameZ0);
	ierr = IGAWriteVec(igaZ0,Z0,pathZ0);CHKERRQ(ierr);		
//

//System for stresses
	#undef  __FUNCT__
	#define __FUNCT__ "Stress"
	//PetscErrorCode Stress(IGAPoint p,IGAPoint pU, IGAPoint pHs,IGAPoint pChi,IGAPoint pZu,PetscReal *K,PetscReal *F,PetscReal *U,PetscReal *HS, PetscReal *Chi,PetscReal *Zu,void *ctx)		//When other fields like Pi or S (etc.) come into this, declare a IGAPoint pPi or pS and a new PescReal *UPi or *US for each
	PetscErrorCode Stress(IGAPoint p, IGAPoint pHs,IGAPoint pChi,IGAPoint pZu,PetscReal *K,PetscReal *F,PetscReal *HS, PetscReal *Chi,PetscReal *Zu,void *ctx)		//When other fields like Pi or S (etc.) come into this, declare a IGAPoint pPi or pS and a new PestcReal *UPi or *US for each
	{
		const PetscReal *N0,(*N1)[2],(*N2)[2][2];
		IGAPointGetShapeFuns(p,0,(const PetscReal**)&N0);									//Value of the shape functions
		IGAPointGetShapeFuns(p,1,(const PetscReal**)&N1);									//Derivatives of the shape functions
		IGAPointGetShapeFuns(p,2,(const PetscReal**)&N2);									//Second derivatives of the shape funcions
		PetscInt a,b,i,j,k,l,m,n,nen=p->nen, dof=p->dof, dofZ=pZu->dof, dimZ=pZu->dim;

		/*
		PetscReal u[2];																	//Array to contain vector u
		PetscReal d_u[2][2];															//Same for its gradient
		PetscReal d2_u[2][2][2];													//Same for its 2nd order partial derivatives
		IGAPointFormValue(pU,U,&u[0]);														//Assign u to its container
		IGAPointFormGrad (pU,U,&d_u[0][0]);													//Same for the gradient
		IGAPointFormHess (pU,U,&d2_u[0][0][0]);												//Same for the hessian
		*/

		PetscReal Hs[4];																	//Array to contain the vector Hs(0)
		PetscReal d_Hs[4][2];																//Same for its gradient
		IGAPointFormValue(pHs,HS,&Hs[0]);													//Assign Hs to its container
		IGAPointFormGrad (pHs,HS,&d_Hs[0][0]);												//Same for the gradient

		PetscReal chi0[4];																	//Array to contain the vector chi(0)
		PetscReal d_Chi0[4][2];																//Same for its gradient
		IGAPointFormValue(pChi,Chi,&chi0[0]);												//Assign chi to its container
		IGAPointFormGrad(pChi,Chi,&d_Chi0[0][0]);											//Assign grad chi to its container
		//IGAPointFormHess (pChi,Chi,&d2_Chi0[0][0][0]);										//This should be the 3-rd order tensor Chi_{i,jk} (remember that we are storing Chi_{kl} as a column vector)

		//PetscReal Z[dofZ];																	//Array to contain the vector z(0)
		PetscReal d_Z0[dofZ][dimZ];															//Same for its gradient
		PetscReal d2_Z0[dofZ][dimZ][dimZ];													//Same for its 2nd order partial derivatives
		//IGAPointFormValue(pHs,Hs,&Hs[0]);													//Assign z to its container  (Z is not used, only its derivatives)
		IGAPointFormGrad (pZu,Zu,&d_Z0[0][0]);												//Same for the gradient
		IGAPointFormHess (pZu,Zu,&d2_Z0[0][0][0]);											//Same for the hessian

		//Expanding Hs so we can use for loops with correct indexing
		PetscReal fullHs[3][3]={0};
		fullHs[0][0]=Hs[0]; 	fullHs[0][1]=Hs[1];
		fullHs[1][0]=Hs[2]; 	fullHs[1][1]=Hs[3];

		PetscReal full_dHs[3][3][3]={0};
		full_dHs[0][0][0]=d_Hs[0][0]; full_dHs[0][0][1]=d_Hs[0][1];
		full_dHs[0][1][0]=d_Hs[1][0]; full_dHs[0][1][1]=d_Hs[1][1];
		full_dHs[1][0][0]=d_Hs[2][0]; full_dHs[1][0][1]=d_Hs[2][1];
		full_dHs[1][1][0]=d_Hs[3][0]; full_dHs[1][1][1]=d_Hs[3][1];

		//Expanding Chi so we can use for loops with correct indexing
		PetscReal fullChi[3][3]={0};
		fullChi[0][0]=chi0[0]; 	fullChi[0][1]=chi0[1];
		fullChi[1][0]=chi0[2]; 	fullChi[1][1]=chi0[3];

		PetscReal fulld_Chi[3][3][3]={0};
		//The four non-zero components of Chi are stored as a vector, restore them to an array with the correct indexing for value and derivative
		fulld_Chi[0][0][0]=d_Chi0[0][0]; fulld_Chi[0][0][1]=d_Chi0[0][1];
		fulld_Chi[0][1][0]=d_Chi0[1][0]; fulld_Chi[0][1][1]=d_Chi0[1][1];
		fulld_Chi[1][0][0]=d_Chi0[2][0]; fulld_Chi[1][0][1]=d_Chi0[2][1];
		fulld_Chi[1][1][0]=d_Chi0[3][0]; fulld_Chi[1][1][1]=d_Chi0[3][1];

		/*
		//Expanding u and z (and derivatives) to 3 components, more convenient for sums in for loops
		PetscReal fulld_u[3][3]={0};
		fulld_u[0][0]=d_u[0][0]; fulld_u[0][1]=d_u[0][1];
		fulld_u[1][0]=d_u[1][0]; fulld_u[1][1]=d_u[1][1];
		
		PetscReal fulld2_u[3][3][3]={0};
		fulld2_u[0][0][0]=d2_u[0][0][0]; fulld2_u[0][0][1]=d2_u[0][0][1];
		fulld2_u[0][1][0]=d2_u[0][1][0]; fulld2_u[0][1][1]=d2_u[0][1][1];
		fulld2_u[1][0][0]=d2_u[1][0][0]; fulld2_u[1][0][1]=d2_u[1][0][1];
		fulld2_u[1][1][0]=d2_u[1][1][0]; fulld2_u[1][1][1]=d2_u[1][1][1];
		*/

		PetscReal fulld_z[3][3]={0};
		fulld_z[0][0]=d_Z0[0][0]; fulld_z[0][1]=d_Z0[0][1];
		fulld_z[1][0]=d_Z0[1][0]; fulld_z[1][1]=d_Z0[1][1];
		
		PetscReal fulld2_z[3][3][3]={0};
		fulld2_z[0][0][0]=d2_Z0[0][0][0]; fulld2_z[0][0][1]=d2_Z0[0][0][1];
		fulld2_z[0][1][0]=d2_Z0[0][1][0]; fulld2_z[0][1][1]=d2_Z0[0][1][1];
		fulld2_z[1][0][0]=d2_Z0[1][0][0]; fulld2_z[1][0][1]=d2_Z0[1][0][1];
		fulld2_z[1][1][0]=d2_Z0[1][1][0]; fulld2_z[1][1][1]=d2_Z0[1][1][1];

		PetscReal (*Kstress)[dof][nen][dof] = (typeof(Kstress)) K;
		PetscReal (*Fstress)[dof] = (PetscReal (*)[dof])F;

		//E and nu should come from AppCtx in the future
		const PetscReal E=2100000.0*9.81*10000.0;
		const PetscReal nu=0.33;
		const PetscReal lambda=(E*nu)/((1.0+nu)*(1.0-2.0*nu));
		const PetscReal mu=E/(2.0*(1.0+nu));
		const PetscReal eps=0.0*1.0/1000.0;														//Choose later based on whatever Amit says :)

		PetscReal C[3][3][3][3]={0};														//Initialization of elastic tensor
		for (i=0; i<3; i++)
		{
			for (j=0; j<3; j++)
			{
				for (k=0; k<3; k++)
				{
					for (l=0; l<3; l++)
					{
						C[i][j][k][l]=lambda*delta(i,j)*delta(k,l)+mu*(delta(i,k)*delta(j,l)+delta(i,l)*delta(j,k));		//Definition of elastic tensor
					}
				}
			}
		}

		if (p->atboundary)
		{
			return 0;
		}
		else
		{
			for (a=0; a<nen; a++) 
			{
				for (b=0; b<nen; b++) 
				{
					for (i=0; i<dof; i++)
					{
						Kstress[a][i][b][i]=N0[a]*N0[b];
					}
				}
			}

			for(a=0 ;a<nen; a++)
			{
				for (i=0; i<dof; i++)
				{
					if (i==0)
					{
						m=0; n=0;
					}
					else if (i==1)
					{
						m=0; n=1;
					}
					else if (i==2)
					{
						m=1; n=0;
					}
					else if (i==3)
					{
						m=1; n=1;
					}
					for (k=0;k<3;k++)
					{
						for(l=0;l<3;l++)
						{
							//Fstress[a][i]+=N0[a]*C[m][n][k][l]*(fulld_u[k][l]-fullChi[k][l]-fulld_z[k][l]+fullHs[k][l]);
							Fstress[a][i]+=N0[a]*C[m][n][k][l]*(-fullChi[k][l]-fulld_z[k][l]+fullHs[k][l]);
						}
						//Fstress[a][i]+=N1[a][k]*0.25*eps*(fulld2_u[m][n][k]-fulld2_z[m][n][k]-fulld_Chi[m][n][k] +fulld2_u[m][k][n]-fulld2_z[m][k][n]-fulld_Chi[m][k][n]
						//								 +fulld2_u[n][m][k]-fulld2_z[n][m][k]-fulld_Chi[n][m][k] +fulld2_u[n][k][m]-fulld2_z[n][k][m]-fulld_Chi[n][k][m]);
						Fstress[a][i]+=N1[a][k]*0.25*eps*(-fulld_Chi[m][n][k]-fulld2_z[m][n][k]+full_dHs[m][n][k]-fulld_Chi[m][k][n]-fulld2_z[m][k][n]+full_dHs[m][k][n]
														  -fulld2_z[n][m][k]-fulld_Chi[n][m][k]+full_dHs[n][m][k]-fulld_Chi[n][k][m]-fulld2_z[n][k][m]+full_dHs[n][k][m]);
					}
				}
			}
		}
		return 0;
	}
//

//System for L2 projection of stress (does not work correctly with the split Ûe=grad(u)-chi-z+Hs)
	printf("System for Stress starting \n");
	IGA igaStress;
	ierr = IGACreate(PETSC_COMM_WORLD,&igaStress);CHKERRQ(ierr);
	ierr = IGASetDim(igaStress,2);CHKERRQ(ierr);													//Spatial dimension of the problem
	ierr = IGASetDof(igaStress,4);CHKERRQ(ierr);													//Number of degrees of freedom, per node
	ierr = IGASetOrder(igaStress,2);CHKERRQ(ierr);													//Number of spatial derivatives to calculate
	ierr = IGASetFromOptions(igaStress);CHKERRQ(ierr);												//Note: The order (or degree) of the shape functions is given by the mesh!
	ierr = IGARead(igaStress,"./geometry2.dat");CHKERRQ(ierr);
	ierr = IGASetUp(igaStress);CHKERRQ(ierr);

	Mat KStress;
	Vec sigma0,FStress;

	ierr = IGACreateMat(igaStress,&KStress);CHKERRQ(ierr);
	ierr = IGACreateVec(igaStress,&sigma0);CHKERRQ(ierr);
	ierr = IGACreateVec(igaStress,&FStress);CHKERRQ(ierr);

	IGAPoint		pointStress;															//point
	IGAElement		elemStress;																//element
	PetscReal		*KlocStress,*FlocStress;												//AA y BB
	PetscReal		*KpointStress,*FpointStress;											//KKK y FFF
	const PetscReal	*arrayUStress,*arrayZ0Stress,*arrayChi0Stress,*arrayHsStress;			//arrayU
	Vec				localUStress,localZ0Stress,localChi0Stress,localHsStress;				//localU
	PetscReal		*UStress,*Chi0Stress,*Z0Stress,*HsStress;											//U

  	IGAFormSystem	wtfStress;
 	void			*wtf2Stress;

 	KSP kspStress;
	ierr = IGACreateKSP(igaStress,&kspStress);CHKERRQ(ierr);

	// Get local vectors u, Z0 and Chi0 and arrays
	//ierr = IGAGetLocalVecArray(igaEq,u0,&localUStress,&arrayUStress);CHKERRQ(ierr);
	ierr = IGAGetLocalVecArray(igachiUp,chiUp0,&localChi0Stress,&arrayChi0Stress);CHKERRQ(ierr);
	ierr = IGAGetLocalVecArray(igaZ0,Z0,&localZ0Stress,&arrayZ0Stress);CHKERRQ(ierr);
	ierr = IGAGetLocalVecArray(igaZS,ZS0,&localHsStress,&arrayHsStress);CHKERRQ(ierr);

	// Element loop
	ierr = IGABeginElement(igaStress,&elemStress);CHKERRQ(ierr);
	//ierr = IGABeginElement(igaEq,&elemEq);CHKERRQ(ierr);
	ierr = IGABeginElement(igaZ0,&elemZ0);CHKERRQ(ierr);
	ierr = IGABeginElement(igachiUp,&elemchiUp);CHKERRQ(ierr);
	ierr = IGABeginElement(igaZS,&elemZS);CHKERRQ(ierr);

	while (IGANextElement(igaStress,elemStress)) 
	{
		//IGANextElement(igaEq,elemEq);
		IGANextElement(igaZ0,elemZ0);
		IGANextElement(igachiUp,elemchiUp);
		IGANextElement(igaZS,elemZS);

		ierr = IGAElementGetWorkMat(elemStress,&KlocStress);CHKERRQ(ierr);
		ierr = IGAElementGetWorkVec(elemStress,&FlocStress);CHKERRQ(ierr);
		//ierr = IGAElementGetValues(elemEq,arrayUStress,&UStress);CHKERRQ(ierr);
		ierr = IGAElementGetValues(elemZ0,arrayZ0Stress,&Z0Stress);CHKERRQ(ierr);
		ierr = IGAElementGetValues(elemchiUp,arrayChi0Stress,&Chi0Stress);CHKERRQ(ierr);
		ierr = IGAElementGetValues(elemZS,arrayHsStress,&HsStress);CHKERRQ(ierr);

		// FormSystem loop
		while (IGAElementNextFormSystem(elemStress,&wtfStress,&wtf2Stress)) 
		{
		// Quadrature loop
			ierr = IGAElementBeginPoint(elemStress,&pointStress);CHKERRQ(ierr);
			//ierr = IGAElementBeginPoint(elemEq,&pointEq);CHKERRQ(ierr);
			ierr = IGAElementBeginPoint(elemZ0,&pointZ0);CHKERRQ(ierr);
			ierr = IGAElementBeginPoint(elemchiUp,&pointchiUp);CHKERRQ(ierr);
			ierr = IGAElementBeginPoint(elemZS,&pointZS);CHKERRQ(ierr);

			while (IGAElementNextPoint(elemStress,pointStress))
			{
				if(pointStress->atboundary==1)
				{
					/*
					ierr = IGAPointGetWorkMat(pointStress,&KpointStress);CHKERRQ(ierr);
					ierr = IGAPointGetWorkVec(pointStress,&FpointStress);CHKERRQ(ierr);
					//Stress(IGAPoint p, IGAPoint pHs,IGAPoint pChi,IGAPoint pZu,PetscReal *K,PetscReal *F,PetscReal *HS, PetscReal *Chi,PetscReal *Zu,void *ctx)
					ierr = Stress(pointStress,pointEq,pointZ0,pointChi,KpointStress,FpointStress,UStress,Z0Stress,Chi0Stress,NULL);CHKERRQ(ierr);
					ierr = IGAPointAddMat(pointStress,KpointStress,KlocStress);CHKERRQ(ierr);
					ierr = IGAPointAddVec(pointStress,FpointStress,FlocStress);CHKERRQ(ierr);
					*/
				}

				//if(pointStress->atboundary==0 && pointEq->atboundary==0 && pointZ0->atboundary==0 && pointChi->atboundary==0)
				if(pointStress->atboundary==0 && pointZ0->atboundary==0 && pointchiUp->atboundary==0 && pointZS->atboundary==0)
				{
					//IGAElementNextPoint(elemEq,pointEq);
					IGAElementNextPoint(elemZ0,pointZ0);
					IGAElementNextPoint(elemchiUp,pointchiUp);
					IGAElementNextPoint(elemZS,pointZS);

					ierr = IGAPointGetWorkMat(pointStress,&KpointStress);CHKERRQ(ierr);
					ierr = IGAPointGetWorkVec(pointStress,&FpointStress);CHKERRQ(ierr);
					//Stress(IGAPoint p, IGAPoint pHs,IGAPoint pChi,IGAPoint pZu,PetscReal *K,PetscReal *F,PetscReal *HS, PetscReal *Chi,PetscReal *Zu,void *ctx)
					ierr = Stress(pointStress,pointZS,pointchiUp,pointZ0,KpointStress,FpointStress,HsStress,Chi0Stress,Z0Stress,NULL);CHKERRQ(ierr);
					ierr = IGAPointAddMat(pointStress,KpointStress,KlocStress);CHKERRQ(ierr);
					ierr = IGAPointAddVec(pointStress,FpointStress,FlocStress);CHKERRQ(ierr);
				}
			}
			//if (pointEq->index != -1)
			//{
			//	IGAElementNextPoint(elemEq,pointEq);
			//}
			if (pointZ0->index != -1)
			{
				IGAElementNextPoint(elemZ0,pointZ0);
			}
			if (pointchiUp->index != -1)
			{
				IGAElementNextPoint(elemchiUp,pointchiUp);
			}
			if (pointZS->index != -1)
			{
				IGAElementNextPoint(elemZS,pointZS);
			}
			ierr = IGAElementEndPoint(elemStress,&pointStress);CHKERRQ(ierr);
			//ierr = IGAElementEndPoint(elemEq,&pointEq);CHKERRQ(ierr);
			ierr = IGAElementEndPoint(elemZ0,&pointZ0);CHKERRQ(ierr);
			ierr = IGAElementEndPoint(elemchiUp,&pointchiUp);CHKERRQ(ierr);
			ierr = IGAElementEndPoint(elemZS,&pointZS);CHKERRQ(ierr);
		}

		ierr = IGAElementFixSystem(elemStress,KlocStress,FlocStress);CHKERRQ(ierr);					//This sets Dirichlet condition ¿? (Yes, this applies the conditions from IGASetBoundaryValue)
		ierr = IGAElementAssembleMat(elemStress,KlocStress,KStress);CHKERRQ(ierr);
		ierr = IGAElementAssembleVec(elemStress,FlocStress,FStress);CHKERRQ(ierr);
	}
	//IGANextElement(igaEq,elemEq);
	IGANextElement(igaZ0,elemZ0);
	IGANextElement(igachiUp,elemchiUp);
	IGANextElement(igaZS,elemZS);

	ierr = IGAEndElement(igaStress,&elemStress);CHKERRQ(ierr);
	//ierr = IGAEndElement(igaEq,&elemEq);CHKERRQ(ierr);
	ierr = IGAEndElement(igaZ0,&elemZ0);CHKERRQ(ierr);
	ierr = IGAEndElement(igachiUp,&elemchiUp);CHKERRQ(ierr);
	ierr = IGAEndElement(igaZS,&elemZS);CHKERRQ(ierr);

	// Restore local vectors u, Z0, Chi0 and arrays
	//ierr = IGARestoreLocalVecArray(igaEq,u0,&localUStress,&arrayUStress);CHKERRQ(ierr);
	ierr = IGARestoreLocalVecArray(igaZ0,Z0,&localZ0Stress,&arrayZ0Stress);CHKERRQ(ierr);
	ierr = IGARestoreLocalVecArray(igachiUp,chiUp0,&localChi0Stress,&arrayChi0Stress);CHKERRQ(ierr);
	ierr = IGARestoreLocalVecArray(igaZS,ZS0,&localHsStress,&arrayHsStress);CHKERRQ(ierr);

	ierr = MatAssemblyBegin(KStress,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
	ierr = MatAssemblyEnd  (KStress,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);

	ierr = VecAssemblyBegin(FStress);CHKERRQ(ierr);
	ierr = VecAssemblyEnd  (FStress);CHKERRQ(ierr);

	ierr = KSPSetOperators(kspStress,KStress,KStress);CHKERRQ(ierr);
	PC pcStress;
	ierr = KSPGetPC(kspStress,&pcStress); CHKERRQ(ierr);
	ierr = PCSetType(pcStress,PCLU); CHKERRQ(ierr);
	ierr = PCFactorSetMatSolverType(pcStress,MATSOLVERMUMPS); CHKERRQ(ierr);
	ierr = KSPSetFromOptions(kspStress);CHKERRQ(ierr);
	ierr = KSPSetFromOptions(kspStress);CHKERRQ(ierr);
	//ierr = KSPSetTolerances(kspStress,1e-18,PETSC_DEFAULT,PETSC_DEFAULT,PETSC_DEFAULT);CHKERRQ(ierr);
	ierr = KSPSolve(kspStress,FStress,sigma0);CHKERRQ(ierr);

	ierr = KSPDestroy(&kspStress);CHKERRQ(ierr);
	ierr = MatDestroy(&KStress);CHKERRQ(ierr);
	ierr = VecDestroy(&FStress);CHKERRQ(ierr);

	char nameStress[]="/sigma-2d-0.dat";
	char pathStress[512];
	sprintf(pathStress,"%s%s",direct,nameStress);
	ierr = IGAWriteVec(igaStress,sigma0,pathStress);CHKERRQ(ierr);	
//